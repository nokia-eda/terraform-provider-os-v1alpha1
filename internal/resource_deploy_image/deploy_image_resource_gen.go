// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_deploy_image

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DeployImageResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alarms": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"critical": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"major": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"minor": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
					"warning": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: AlarmsType{
					ObjectType: types.ObjectType{
						AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^os\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("os.eda.nokia.com/v1alpha1"),
			},
			"deviations": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"count": schema.Int64Attribute{
						Optional: true,
						Computed: true,
					},
				},
				CustomType: DeviationsType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^DeployImage$"), ""),
				},
				Default: stringdefault.StaticString("DeployImage"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the DeployImage",
				MarkdownDescription: "name of the DeployImage",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"canaries": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of node selectors to use to match canary nodes.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nCanary nodes are upgraded before any other nodes, and are used to test images before broader roll out.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=canary\"].",
						MarkdownDescription: "List of node selectors to use to match canary nodes.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nCanary nodes are upgraded before any other nodes, and are used to test images before broader roll out.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=canary\"].",
					},
					"checks": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"checks": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Checks to run before (pre) and after (post) any image changes.\nIf none are specified, a default set of checks will be run.",
								MarkdownDescription: "Checks to run before (pre) and after (post) any image changes.\nIf none are specified, a default set of checks will be run.",
							},
							"force": schema.BoolAttribute{
								Optional:            true,
								Description:         "Ignore result of pre and post checks, do not prompt on failure.",
								MarkdownDescription: "Ignore result of pre and post checks, do not prompt on failure.",
							},
							"skip": schema.BoolAttribute{
								Optional:            true,
								Description:         "Do not run any checks pre or post image change.",
								MarkdownDescription: "Do not run any checks pre or post image change.",
							},
						},
						CustomType: ChecksType{
							ObjectType: types.ObjectType{
								AttrTypes: ChecksValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Configure pre and post checks.",
						MarkdownDescription: "Configure pre and post checks.",
					},
					"drains": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"minimum_wait_time_seconds": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Seconds to wait before rebooting a node after it has been drained.\nThis is used to allow time for any traffic to drain away from the node before reboot.",
								MarkdownDescription: "Seconds to wait before rebooting a node after it has been drained.\nThis is used to allow time for any traffic to drain away from the node before reboot.",
								Default:             int64default.StaticInt64(60),
							},
							"skip": schema.BoolAttribute{
								Optional:            true,
								Description:         "Do not run any drain operations. Nodes will be rebooted without attempting to gracefully drain them.",
								MarkdownDescription: "Do not run any drain operations. Nodes will be rebooted without attempting to gracefully drain them.",
							},
						},
						CustomType: DrainsType{
							ObjectType: types.ObjectType{
								AttrTypes: DrainsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Configure drains to gracefully drain traffic away from nodes before imaging.",
						MarkdownDescription: "Configure drains to gracefully drain traffic away from nodes before imaging.",
					},
					"node_profile": schema.StringAttribute{
						Required:            true,
						Description:         "Destination profile to use for imaging.\nThis profile contains the image to deploy, and other configuration for the node.",
						MarkdownDescription: "Destination profile to use for imaging.\nThis profile contains the image to deploy, and other configuration for the node.",
					},
					"node_selectors": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of node selectors to select nodes to deploy images on.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\"].",
						MarkdownDescription: "List of node selectors to select nodes to deploy images on.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nIf no nodes are specified, and no node selectors are specified, all nodes in the given namespace will be selected.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\"].",
					},
					"nodes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of nodes to deploy images on.",
						MarkdownDescription: "List of nodes to deploy images on.",
					},
					"prompt": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Control when to prompt the user for input.\nIf any pre or post checks fail, the user will be prompted for input, but this may be used to prompt even if they're successful.",
						MarkdownDescription: "Control when to prompt the user for input.\nIf any pre or post checks fail, the user will be prompted for input, but this may be used to prompt even if they're successful.",
					},
					"reconnection_timeout_seconds": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Seconds to wait for node to come back online after reboot.",
						MarkdownDescription: "Seconds to wait for node to come back online after reboot.",
						Default:             int64default.StaticInt64(600),
					},
					"tranches": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Optional:            true,
									Description:         "Name of the tranche.\nThis is used to identify the tranche in the UI and in logs.",
									MarkdownDescription: "Name of the tranche.\nThis is used to identify the tranche in the UI and in logs.",
								},
								"node_selectors": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Node Selectors is a list of node selectors to select nodes to deploy images on in this tranche.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\"].",
									MarkdownDescription: "Node Selectors is a list of node selectors to select nodes to deploy images on in this tranche.\nThis matches labels on TopoNode resources, including those TopoNodes in the list of nodes that will be imaged.\nThis is a list of label expressions, e.g. [\"eda.nokia.com/role=leaf\"].",
								},
							},
							CustomType: TranchesType{
								ObjectType: types.ObjectType{
									AttrTypes: TranchesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "List of tranches to use for imaging.\nA tranche is a list of node selectors, and a name.\nTranches are upgraded in order, sequentially.",
						MarkdownDescription: "List of tranches to use for imaging.\nA tranche is a list of node selectors, and a name.\nTranches are upgraded in order, sequentially.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Upgrade / downgrade images on targets.\nThis workflow can be used directly on a target or list of targets, or with selectors to select targets through labels.\nIt also supports tranches, which are groups of targets that can be upgraded together.\nBy default a set of checks are run before and after the image change, but this can be controlled via the checks field.\nIt also supports canaries, which are upgraded before any other targets.",
				MarkdownDescription: "Upgrade / downgrade images on targets.\nThis workflow can be used directly on a target or list of targets, or with selectors to select targets through labels.\nIt also supports tranches, which are groups of targets that can be upgraded together.\nBy default a set of checks are run before and after the image change, but this can be controlled via the checks field.\nIt also supports canaries, which are upgraded before any other targets.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"details": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"drained_time": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The time when the node was drained.\nThis is the time when the node was drained before the imaging operation.",
									MarkdownDescription: "The time when the node was drained.\nThis is the time when the node was drained before the imaging operation.",
								},
								"new_node_profile": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The new profile of the node.",
									MarkdownDescription: "The new profile of the node.",
								},
								"new_version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The new version of the node.",
									MarkdownDescription: "The new version of the node.",
								},
								"node": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The name of the node this result is for.",
									MarkdownDescription: "The name of the node this result is for.",
								},
								"post_check_successful": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates if post checks were successful for this node.\nThis is true if all post checks passed, false if any post checks failed.",
									MarkdownDescription: "Indicates if post checks were successful for this node.\nThis is true if all post checks passed, false if any post checks failed.",
								},
								"pre_check_successful": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates if pre checks were successful for this node.\nThis is true if all pre checks passed, false if any pre checks failed.",
									MarkdownDescription: "Indicates if pre checks were successful for this node.\nThis is true if all pre checks passed, false if any pre checks failed.",
								},
								"previous_node_profile": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The previous profile of the node.\nThis is the node profile that was running before the imaging operation.",
									MarkdownDescription: "The previous profile of the node.\nThis is the node profile that was running before the imaging operation.",
								},
								"previous_version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The previous version of the node.\nThis is the version of the image that was running before the imaging operation.",
									MarkdownDescription: "The previous version of the node.\nThis is the version of the image that was running before the imaging operation.",
								},
								"reboot_recovery_time": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The time when the node was recovered after reboot.\nThis is the time when the node was recovered after the imaging operation.",
									MarkdownDescription: "The time when the node was recovered after reboot.\nThis is the time when the node was recovered after the imaging operation.",
								},
								"reboot_time": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The time when the node was rebooted.\nThis is the time when the node was rebooted during the imaging operation.",
									MarkdownDescription: "The time when the node was rebooted.\nThis is the time when the node was rebooted during the imaging operation.",
								},
								"success": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Indicates if the imaging operation was successful for this node.\nThis is true if the imaging operation was successful, false if it failed.",
									MarkdownDescription: "Indicates if the imaging operation was successful for this node.\nThis is true if the imaging operation was successful, false if it failed.",
								},
								"undrained_time": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The time when the node was undrained.\nThis is the time when the node was undrained after the imaging operation.",
									MarkdownDescription: "The time when the node was undrained.\nThis is the time when the node was undrained after the imaging operation.",
								},
							},
							CustomType: DetailsType{
								ObjectType: types.ObjectType{
									AttrTypes: DetailsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Per-node image deployment details.",
						MarkdownDescription: "Per-node image deployment details.",
					},
					"first_node_drained": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The time when the first node was drained.",
						MarkdownDescription: "The time when the first node was drained.",
					},
					"first_node_rebooted": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The time when the first node was rebooted.",
						MarkdownDescription: "The time when the first node was rebooted.",
					},
					"last_node_reboot_recovered": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The time when the last node recovered post reboot.",
						MarkdownDescription: "The time when the last node recovered post reboot.",
					},
					"last_node_undrained": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The time when the last node was undrained.",
						MarkdownDescription: "The time when the last node was undrained.",
					},
					"result": schema.StringAttribute{
						Required:            true,
						Description:         "Result is the overall result of the image operation.\nIt can be one of the following values:\n- \"Success\": All images were successfully deployed.\n- \"Failed\": No images were successfully deployed.\n- \"PartialSuccess\": Some images were successfully deployed, but not all.",
						MarkdownDescription: "Result is the overall result of the image operation.\nIt can be one of the following values:\n- \"Success\": All images were successfully deployed.\n- \"Failed\": No images were successfully deployed.\n- \"PartialSuccess\": Some images were successfully deployed, but not all.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"Success",
								"Failed",
								"PartialSuccess",
							),
						},
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Status of the imaging operation.",
				MarkdownDescription: "Status of the imaging operation.",
			},
		},
	}
}

type DeployImageModel struct {
	Alarms     AlarmsValue     `tfsdk:"alarms"`
	ApiVersion types.String    `tfsdk:"api_version"`
	Deviations DeviationsValue `tfsdk:"deviations"`
	Kind       types.String    `tfsdk:"kind"`
	Metadata   MetadataValue   `tfsdk:"metadata"`
	Name       types.String    `tfsdk:"name"`
	Namespace  types.String    `tfsdk:"namespace"`
	Spec       SpecValue       `tfsdk:"spec"`
	Status     StatusValue     `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canariesAttribute, ok := attributes["canaries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canaries is missing from object`)

		return nil, diags
	}

	canariesVal, ok := canariesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canaries expected to be basetypes.ListValue, was: %T`, canariesAttribute))
	}

	checksAttribute, ok := attributes["checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checks is missing from object`)

		return nil, diags
	}

	checksVal, ok := checksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checks expected to be basetypes.ObjectValue, was: %T`, checksAttribute))
	}

	drainsAttribute, ok := attributes["drains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drains is missing from object`)

		return nil, diags
	}

	drainsVal, ok := drainsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drains expected to be basetypes.ObjectValue, was: %T`, drainsAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return nil, diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return nil, diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	promptAttribute, ok := attributes["prompt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prompt is missing from object`)

		return nil, diags
	}

	promptVal, ok := promptAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prompt expected to be basetypes.ListValue, was: %T`, promptAttribute))
	}

	reconnectionTimeoutSecondsAttribute, ok := attributes["reconnection_timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reconnection_timeout_seconds is missing from object`)

		return nil, diags
	}

	reconnectionTimeoutSecondsVal, ok := reconnectionTimeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reconnection_timeout_seconds expected to be basetypes.Int64Value, was: %T`, reconnectionTimeoutSecondsAttribute))
	}

	tranchesAttribute, ok := attributes["tranches"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tranches is missing from object`)

		return nil, diags
	}

	tranchesVal, ok := tranchesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tranches expected to be basetypes.ListValue, was: %T`, tranchesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Canaries:                   canariesVal,
		Checks:                     checksVal,
		Drains:                     drainsVal,
		NodeProfile:                nodeProfileVal,
		NodeSelectors:              nodeSelectorsVal,
		Nodes:                      nodesVal,
		Prompt:                     promptVal,
		ReconnectionTimeoutSeconds: reconnectionTimeoutSecondsVal,
		Tranches:                   tranchesVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	canariesAttribute, ok := attributes["canaries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`canaries is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	canariesVal, ok := canariesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`canaries expected to be basetypes.ListValue, was: %T`, canariesAttribute))
	}

	checksAttribute, ok := attributes["checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checks is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	checksVal, ok := checksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checks expected to be basetypes.ObjectValue, was: %T`, checksAttribute))
	}

	drainsAttribute, ok := attributes["drains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drains is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	drainsVal, ok := drainsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drains expected to be basetypes.ObjectValue, was: %T`, drainsAttribute))
	}

	nodeProfileAttribute, ok := attributes["node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_profile is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeProfileVal, ok := nodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_profile expected to be basetypes.StringValue, was: %T`, nodeProfileAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	promptAttribute, ok := attributes["prompt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prompt is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	promptVal, ok := promptAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prompt expected to be basetypes.ListValue, was: %T`, promptAttribute))
	}

	reconnectionTimeoutSecondsAttribute, ok := attributes["reconnection_timeout_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reconnection_timeout_seconds is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	reconnectionTimeoutSecondsVal, ok := reconnectionTimeoutSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reconnection_timeout_seconds expected to be basetypes.Int64Value, was: %T`, reconnectionTimeoutSecondsAttribute))
	}

	tranchesAttribute, ok := attributes["tranches"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tranches is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	tranchesVal, ok := tranchesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tranches expected to be basetypes.ListValue, was: %T`, tranchesAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Canaries:                   canariesVal,
		Checks:                     checksVal,
		Drains:                     drainsVal,
		NodeProfile:                nodeProfileVal,
		NodeSelectors:              nodeSelectorsVal,
		Nodes:                      nodesVal,
		Prompt:                     promptVal,
		ReconnectionTimeoutSeconds: reconnectionTimeoutSecondsVal,
		Tranches:                   tranchesVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Canaries                   basetypes.ListValue   `tfsdk:"canaries"`
	Checks                     basetypes.ObjectValue `tfsdk:"checks"`
	Drains                     basetypes.ObjectValue `tfsdk:"drains"`
	NodeProfile                basetypes.StringValue `tfsdk:"node_profile"`
	NodeSelectors              basetypes.ListValue   `tfsdk:"node_selectors"`
	Nodes                      basetypes.ListValue   `tfsdk:"nodes"`
	Prompt                     basetypes.ListValue   `tfsdk:"prompt"`
	ReconnectionTimeoutSeconds basetypes.Int64Value  `tfsdk:"reconnection_timeout_seconds"`
	Tranches                   basetypes.ListValue   `tfsdk:"tranches"`
	state                      attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["canaries"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["checks"] = basetypes.ObjectType{
		AttrTypes: ChecksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["drains"] = basetypes.ObjectType{
		AttrTypes: DrainsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["node_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_selectors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["prompt"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["reconnection_timeout_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tranches"] = basetypes.ListType{
		ElemType: TranchesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Canaries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["canaries"] = val

		val, err = v.Checks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["checks"] = val

		val, err = v.Drains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drains"] = val

		val, err = v.NodeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_profile"] = val

		val, err = v.NodeSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selectors"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.Prompt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prompt"] = val

		val, err = v.ReconnectionTimeoutSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reconnection_timeout_seconds"] = val

		val, err = v.Tranches.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tranches"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var checks basetypes.ObjectValue

	if v.Checks.IsNull() {
		checks = types.ObjectNull(
			ChecksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Checks.IsUnknown() {
		checks = types.ObjectUnknown(
			ChecksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Checks.IsNull() && !v.Checks.IsUnknown() {
		checks = types.ObjectValueMust(
			ChecksValue{}.AttributeTypes(ctx),
			v.Checks.Attributes(),
		)
	}

	var drains basetypes.ObjectValue

	if v.Drains.IsNull() {
		drains = types.ObjectNull(
			DrainsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Drains.IsUnknown() {
		drains = types.ObjectUnknown(
			DrainsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Drains.IsNull() && !v.Drains.IsUnknown() {
		drains = types.ObjectValueMust(
			DrainsValue{}.AttributeTypes(ctx),
			v.Drains.Attributes(),
		)
	}

	tranches := types.ListValueMust(
		TranchesType{
			basetypes.ObjectType{
				AttrTypes: TranchesValue{}.AttributeTypes(ctx),
			},
		},
		v.Tranches.Elements(),
	)

	if v.Tranches.IsNull() {
		tranches = types.ListNull(
			TranchesType{
				basetypes.ObjectType{
					AttrTypes: TranchesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tranches.IsUnknown() {
		tranches = types.ListUnknown(
			TranchesType{
				basetypes.ObjectType{
					AttrTypes: TranchesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var canariesVal basetypes.ListValue
	switch {
	case v.Canaries.IsUnknown():
		canariesVal = types.ListUnknown(types.StringType)
	case v.Canaries.IsNull():
		canariesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		canariesVal, d = types.ListValue(types.StringType, v.Canaries.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"canaries": basetypes.ListType{
				ElemType: types.StringType,
			},
			"checks": basetypes.ObjectType{
				AttrTypes: ChecksValue{}.AttributeTypes(ctx),
			},
			"drains": basetypes.ObjectType{
				AttrTypes: DrainsValue{}.AttributeTypes(ctx),
			},
			"node_profile": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prompt": basetypes.ListType{
				ElemType: types.StringType,
			},
			"reconnection_timeout_seconds": basetypes.Int64Type{},
			"tranches": basetypes.ListType{
				ElemType: TranchesValue{}.Type(ctx),
			},
		}), diags
	}

	var nodeSelectorsVal basetypes.ListValue
	switch {
	case v.NodeSelectors.IsUnknown():
		nodeSelectorsVal = types.ListUnknown(types.StringType)
	case v.NodeSelectors.IsNull():
		nodeSelectorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorsVal, d = types.ListValue(types.StringType, v.NodeSelectors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"canaries": basetypes.ListType{
				ElemType: types.StringType,
			},
			"checks": basetypes.ObjectType{
				AttrTypes: ChecksValue{}.AttributeTypes(ctx),
			},
			"drains": basetypes.ObjectType{
				AttrTypes: DrainsValue{}.AttributeTypes(ctx),
			},
			"node_profile": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prompt": basetypes.ListType{
				ElemType: types.StringType,
			},
			"reconnection_timeout_seconds": basetypes.Int64Type{},
			"tranches": basetypes.ListType{
				ElemType: TranchesValue{}.Type(ctx),
			},
		}), diags
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"canaries": basetypes.ListType{
				ElemType: types.StringType,
			},
			"checks": basetypes.ObjectType{
				AttrTypes: ChecksValue{}.AttributeTypes(ctx),
			},
			"drains": basetypes.ObjectType{
				AttrTypes: DrainsValue{}.AttributeTypes(ctx),
			},
			"node_profile": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prompt": basetypes.ListType{
				ElemType: types.StringType,
			},
			"reconnection_timeout_seconds": basetypes.Int64Type{},
			"tranches": basetypes.ListType{
				ElemType: TranchesValue{}.Type(ctx),
			},
		}), diags
	}

	var promptVal basetypes.ListValue
	switch {
	case v.Prompt.IsUnknown():
		promptVal = types.ListUnknown(types.StringType)
	case v.Prompt.IsNull():
		promptVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		promptVal, d = types.ListValue(types.StringType, v.Prompt.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"canaries": basetypes.ListType{
				ElemType: types.StringType,
			},
			"checks": basetypes.ObjectType{
				AttrTypes: ChecksValue{}.AttributeTypes(ctx),
			},
			"drains": basetypes.ObjectType{
				AttrTypes: DrainsValue{}.AttributeTypes(ctx),
			},
			"node_profile": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prompt": basetypes.ListType{
				ElemType: types.StringType,
			},
			"reconnection_timeout_seconds": basetypes.Int64Type{},
			"tranches": basetypes.ListType{
				ElemType: TranchesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"canaries": basetypes.ListType{
			ElemType: types.StringType,
		},
		"checks": basetypes.ObjectType{
			AttrTypes: ChecksValue{}.AttributeTypes(ctx),
		},
		"drains": basetypes.ObjectType{
			AttrTypes: DrainsValue{}.AttributeTypes(ctx),
		},
		"node_profile": basetypes.StringType{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prompt": basetypes.ListType{
			ElemType: types.StringType,
		},
		"reconnection_timeout_seconds": basetypes.Int64Type{},
		"tranches": basetypes.ListType{
			ElemType: TranchesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"canaries":                     canariesVal,
			"checks":                       checks,
			"drains":                       drains,
			"node_profile":                 v.NodeProfile,
			"node_selectors":               nodeSelectorsVal,
			"nodes":                        nodesVal,
			"prompt":                       promptVal,
			"reconnection_timeout_seconds": v.ReconnectionTimeoutSeconds,
			"tranches":                     tranches,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Canaries.Equal(other.Canaries) {
		return false
	}

	if !v.Checks.Equal(other.Checks) {
		return false
	}

	if !v.Drains.Equal(other.Drains) {
		return false
	}

	if !v.NodeProfile.Equal(other.NodeProfile) {
		return false
	}

	if !v.NodeSelectors.Equal(other.NodeSelectors) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.Prompt.Equal(other.Prompt) {
		return false
	}

	if !v.ReconnectionTimeoutSeconds.Equal(other.ReconnectionTimeoutSeconds) {
		return false
	}

	if !v.Tranches.Equal(other.Tranches) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"canaries": basetypes.ListType{
			ElemType: types.StringType,
		},
		"checks": basetypes.ObjectType{
			AttrTypes: ChecksValue{}.AttributeTypes(ctx),
		},
		"drains": basetypes.ObjectType{
			AttrTypes: DrainsValue{}.AttributeTypes(ctx),
		},
		"node_profile": basetypes.StringType{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prompt": basetypes.ListType{
			ElemType: types.StringType,
		},
		"reconnection_timeout_seconds": basetypes.Int64Type{},
		"tranches": basetypes.ListType{
			ElemType: TranchesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ChecksType{}

type ChecksType struct {
	basetypes.ObjectType
}

func (t ChecksType) Equal(o attr.Type) bool {
	other, ok := o.(ChecksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChecksType) String() string {
	return "ChecksType"
}

func (t ChecksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	checksAttribute, ok := attributes["checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checks is missing from object`)

		return nil, diags
	}

	checksVal, ok := checksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checks expected to be basetypes.ListValue, was: %T`, checksAttribute))
	}

	forceAttribute, ok := attributes["force"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force is missing from object`)

		return nil, diags
	}

	forceVal, ok := forceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force expected to be basetypes.BoolValue, was: %T`, forceAttribute))
	}

	skipAttribute, ok := attributes["skip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip is missing from object`)

		return nil, diags
	}

	skipVal, ok := skipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip expected to be basetypes.BoolValue, was: %T`, skipAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChecksValue{
		Checks: checksVal,
		Force:  forceVal,
		Skip:   skipVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewChecksValueNull() ChecksValue {
	return ChecksValue{
		state: attr.ValueStateNull,
	}
}

func NewChecksValueUnknown() ChecksValue {
	return ChecksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChecksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChecksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChecksValue Attribute Value",
				"While creating a ChecksValue value, a missing attribute value was detected. "+
					"A ChecksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChecksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChecksValue Attribute Type",
				"While creating a ChecksValue value, an invalid attribute value was detected. "+
					"A ChecksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChecksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChecksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChecksValue Attribute Value",
				"While creating a ChecksValue value, an extra attribute value was detected. "+
					"A ChecksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChecksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChecksValueUnknown(), diags
	}

	checksAttribute, ok := attributes["checks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`checks is missing from object`)

		return NewChecksValueUnknown(), diags
	}

	checksVal, ok := checksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`checks expected to be basetypes.ListValue, was: %T`, checksAttribute))
	}

	forceAttribute, ok := attributes["force"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force is missing from object`)

		return NewChecksValueUnknown(), diags
	}

	forceVal, ok := forceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force expected to be basetypes.BoolValue, was: %T`, forceAttribute))
	}

	skipAttribute, ok := attributes["skip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip is missing from object`)

		return NewChecksValueUnknown(), diags
	}

	skipVal, ok := skipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip expected to be basetypes.BoolValue, was: %T`, skipAttribute))
	}

	if diags.HasError() {
		return NewChecksValueUnknown(), diags
	}

	return ChecksValue{
		Checks: checksVal,
		Force:  forceVal,
		Skip:   skipVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewChecksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChecksValue {
	object, diags := NewChecksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChecksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChecksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChecksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChecksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChecksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChecksValueMust(ChecksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChecksType) ValueType(ctx context.Context) attr.Value {
	return ChecksValue{}
}

var _ basetypes.ObjectValuable = ChecksValue{}

type ChecksValue struct {
	Checks basetypes.ListValue `tfsdk:"checks"`
	Force  basetypes.BoolValue `tfsdk:"force"`
	Skip   basetypes.BoolValue `tfsdk:"skip"`
	state  attr.ValueState
}

func (v ChecksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["checks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["force"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["skip"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Checks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["checks"] = val

		val, err = v.Force.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["force"] = val

		val, err = v.Skip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChecksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChecksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChecksValue) String() string {
	return "ChecksValue"
}

func (v ChecksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var checksVal basetypes.ListValue
	switch {
	case v.Checks.IsUnknown():
		checksVal = types.ListUnknown(types.StringType)
	case v.Checks.IsNull():
		checksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		checksVal, d = types.ListValue(types.StringType, v.Checks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"checks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"force": basetypes.BoolType{},
			"skip":  basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"checks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"force": basetypes.BoolType{},
		"skip":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"checks": checksVal,
			"force":  v.Force,
			"skip":   v.Skip,
		})

	return objVal, diags
}

func (v ChecksValue) Equal(o attr.Value) bool {
	other, ok := o.(ChecksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Checks.Equal(other.Checks) {
		return false
	}

	if !v.Force.Equal(other.Force) {
		return false
	}

	if !v.Skip.Equal(other.Skip) {
		return false
	}

	return true
}

func (v ChecksValue) Type(ctx context.Context) attr.Type {
	return ChecksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChecksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"checks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"force": basetypes.BoolType{},
		"skip":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = DrainsType{}

type DrainsType struct {
	basetypes.ObjectType
}

func (t DrainsType) Equal(o attr.Type) bool {
	other, ok := o.(DrainsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DrainsType) String() string {
	return "DrainsType"
}

func (t DrainsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	minimumWaitTimeSecondsAttribute, ok := attributes["minimum_wait_time_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_wait_time_seconds is missing from object`)

		return nil, diags
	}

	minimumWaitTimeSecondsVal, ok := minimumWaitTimeSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_wait_time_seconds expected to be basetypes.Int64Value, was: %T`, minimumWaitTimeSecondsAttribute))
	}

	skipAttribute, ok := attributes["skip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip is missing from object`)

		return nil, diags
	}

	skipVal, ok := skipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip expected to be basetypes.BoolValue, was: %T`, skipAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DrainsValue{
		MinimumWaitTimeSeconds: minimumWaitTimeSecondsVal,
		Skip:                   skipVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDrainsValueNull() DrainsValue {
	return DrainsValue{
		state: attr.ValueStateNull,
	}
}

func NewDrainsValueUnknown() DrainsValue {
	return DrainsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDrainsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DrainsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DrainsValue Attribute Value",
				"While creating a DrainsValue value, a missing attribute value was detected. "+
					"A DrainsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DrainsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DrainsValue Attribute Type",
				"While creating a DrainsValue value, an invalid attribute value was detected. "+
					"A DrainsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DrainsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DrainsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DrainsValue Attribute Value",
				"While creating a DrainsValue value, an extra attribute value was detected. "+
					"A DrainsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DrainsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDrainsValueUnknown(), diags
	}

	minimumWaitTimeSecondsAttribute, ok := attributes["minimum_wait_time_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_wait_time_seconds is missing from object`)

		return NewDrainsValueUnknown(), diags
	}

	minimumWaitTimeSecondsVal, ok := minimumWaitTimeSecondsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_wait_time_seconds expected to be basetypes.Int64Value, was: %T`, minimumWaitTimeSecondsAttribute))
	}

	skipAttribute, ok := attributes["skip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip is missing from object`)

		return NewDrainsValueUnknown(), diags
	}

	skipVal, ok := skipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip expected to be basetypes.BoolValue, was: %T`, skipAttribute))
	}

	if diags.HasError() {
		return NewDrainsValueUnknown(), diags
	}

	return DrainsValue{
		MinimumWaitTimeSeconds: minimumWaitTimeSecondsVal,
		Skip:                   skipVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewDrainsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DrainsValue {
	object, diags := NewDrainsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDrainsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DrainsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDrainsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDrainsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDrainsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDrainsValueMust(DrainsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DrainsType) ValueType(ctx context.Context) attr.Value {
	return DrainsValue{}
}

var _ basetypes.ObjectValuable = DrainsValue{}

type DrainsValue struct {
	MinimumWaitTimeSeconds basetypes.Int64Value `tfsdk:"minimum_wait_time_seconds"`
	Skip                   basetypes.BoolValue  `tfsdk:"skip"`
	state                  attr.ValueState
}

func (v DrainsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["minimum_wait_time_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["skip"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MinimumWaitTimeSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_wait_time_seconds"] = val

		val, err = v.Skip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DrainsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DrainsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DrainsValue) String() string {
	return "DrainsValue"
}

func (v DrainsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"minimum_wait_time_seconds": basetypes.Int64Type{},
		"skip":                      basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"minimum_wait_time_seconds": v.MinimumWaitTimeSeconds,
			"skip":                      v.Skip,
		})

	return objVal, diags
}

func (v DrainsValue) Equal(o attr.Value) bool {
	other, ok := o.(DrainsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MinimumWaitTimeSeconds.Equal(other.MinimumWaitTimeSeconds) {
		return false
	}

	if !v.Skip.Equal(other.Skip) {
		return false
	}

	return true
}

func (v DrainsValue) Type(ctx context.Context) attr.Type {
	return DrainsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DrainsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"minimum_wait_time_seconds": basetypes.Int64Type{},
		"skip":                      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = TranchesType{}

type TranchesType struct {
	basetypes.ObjectType
}

func (t TranchesType) Equal(o attr.Type) bool {
	other, ok := o.(TranchesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TranchesType) String() string {
	return "TranchesType"
}

func (t TranchesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return nil, diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TranchesValue{
		Name:          nameVal,
		NodeSelectors: nodeSelectorsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewTranchesValueNull() TranchesValue {
	return TranchesValue{
		state: attr.ValueStateNull,
	}
}

func NewTranchesValueUnknown() TranchesValue {
	return TranchesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTranchesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TranchesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TranchesValue Attribute Value",
				"While creating a TranchesValue value, a missing attribute value was detected. "+
					"A TranchesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TranchesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TranchesValue Attribute Type",
				"While creating a TranchesValue value, an invalid attribute value was detected. "+
					"A TranchesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TranchesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TranchesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TranchesValue Attribute Value",
				"While creating a TranchesValue value, an extra attribute value was detected. "+
					"A TranchesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TranchesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTranchesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTranchesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeSelectorsAttribute, ok := attributes["node_selectors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selectors is missing from object`)

		return NewTranchesValueUnknown(), diags
	}

	nodeSelectorsVal, ok := nodeSelectorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selectors expected to be basetypes.ListValue, was: %T`, nodeSelectorsAttribute))
	}

	if diags.HasError() {
		return NewTranchesValueUnknown(), diags
	}

	return TranchesValue{
		Name:          nameVal,
		NodeSelectors: nodeSelectorsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewTranchesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TranchesValue {
	object, diags := NewTranchesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTranchesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TranchesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTranchesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTranchesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTranchesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTranchesValueMust(TranchesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TranchesType) ValueType(ctx context.Context) attr.Value {
	return TranchesValue{}
}

var _ basetypes.ObjectValuable = TranchesValue{}

type TranchesValue struct {
	Name          basetypes.StringValue `tfsdk:"name"`
	NodeSelectors basetypes.ListValue   `tfsdk:"node_selectors"`
	state         attr.ValueState
}

func (v TranchesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_selectors"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeSelectors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selectors"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TranchesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TranchesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TranchesValue) String() string {
	return "TranchesValue"
}

func (v TranchesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodeSelectorsVal basetypes.ListValue
	switch {
	case v.NodeSelectors.IsUnknown():
		nodeSelectorsVal = types.ListUnknown(types.StringType)
	case v.NodeSelectors.IsNull():
		nodeSelectorsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorsVal, d = types.ListValue(types.StringType, v.NodeSelectors.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"name": basetypes.StringType{},
			"node_selectors": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":           v.Name,
			"node_selectors": nodeSelectorsVal,
		})

	return objVal, diags
}

func (v TranchesValue) Equal(o attr.Value) bool {
	other, ok := o.(TranchesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeSelectors.Equal(other.NodeSelectors) {
		return false
	}

	return true
}

func (v TranchesValue) Type(ctx context.Context) attr.Type {
	return TranchesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TranchesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"node_selectors": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return nil, diags
	}

	detailsVal, ok := detailsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be basetypes.ListValue, was: %T`, detailsAttribute))
	}

	firstNodeDrainedAttribute, ok := attributes["first_node_drained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_node_drained is missing from object`)

		return nil, diags
	}

	firstNodeDrainedVal, ok := firstNodeDrainedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_node_drained expected to be basetypes.StringValue, was: %T`, firstNodeDrainedAttribute))
	}

	firstNodeRebootedAttribute, ok := attributes["first_node_rebooted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_node_rebooted is missing from object`)

		return nil, diags
	}

	firstNodeRebootedVal, ok := firstNodeRebootedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_node_rebooted expected to be basetypes.StringValue, was: %T`, firstNodeRebootedAttribute))
	}

	lastNodeRebootRecoveredAttribute, ok := attributes["last_node_reboot_recovered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_node_reboot_recovered is missing from object`)

		return nil, diags
	}

	lastNodeRebootRecoveredVal, ok := lastNodeRebootRecoveredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_node_reboot_recovered expected to be basetypes.StringValue, was: %T`, lastNodeRebootRecoveredAttribute))
	}

	lastNodeUndrainedAttribute, ok := attributes["last_node_undrained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_node_undrained is missing from object`)

		return nil, diags
	}

	lastNodeUndrainedVal, ok := lastNodeUndrainedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_node_undrained expected to be basetypes.StringValue, was: %T`, lastNodeUndrainedAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return nil, diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Details:                 detailsVal,
		FirstNodeDrained:        firstNodeDrainedVal,
		FirstNodeRebooted:       firstNodeRebootedVal,
		LastNodeRebootRecovered: lastNodeRebootRecoveredVal,
		LastNodeUndrained:       lastNodeUndrainedVal,
		Result:                  resultVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	detailsAttribute, ok := attributes["details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`details is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	detailsVal, ok := detailsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`details expected to be basetypes.ListValue, was: %T`, detailsAttribute))
	}

	firstNodeDrainedAttribute, ok := attributes["first_node_drained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_node_drained is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	firstNodeDrainedVal, ok := firstNodeDrainedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_node_drained expected to be basetypes.StringValue, was: %T`, firstNodeDrainedAttribute))
	}

	firstNodeRebootedAttribute, ok := attributes["first_node_rebooted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_node_rebooted is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	firstNodeRebootedVal, ok := firstNodeRebootedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_node_rebooted expected to be basetypes.StringValue, was: %T`, firstNodeRebootedAttribute))
	}

	lastNodeRebootRecoveredAttribute, ok := attributes["last_node_reboot_recovered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_node_reboot_recovered is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastNodeRebootRecoveredVal, ok := lastNodeRebootRecoveredAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_node_reboot_recovered expected to be basetypes.StringValue, was: %T`, lastNodeRebootRecoveredAttribute))
	}

	lastNodeUndrainedAttribute, ok := attributes["last_node_undrained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_node_undrained is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastNodeUndrainedVal, ok := lastNodeUndrainedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_node_undrained expected to be basetypes.StringValue, was: %T`, lastNodeUndrainedAttribute))
	}

	resultAttribute, ok := attributes["result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`result is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	resultVal, ok := resultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`result expected to be basetypes.StringValue, was: %T`, resultAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Details:                 detailsVal,
		FirstNodeDrained:        firstNodeDrainedVal,
		FirstNodeRebooted:       firstNodeRebootedVal,
		LastNodeRebootRecovered: lastNodeRebootRecoveredVal,
		LastNodeUndrained:       lastNodeUndrainedVal,
		Result:                  resultVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Details                 basetypes.ListValue   `tfsdk:"details"`
	FirstNodeDrained        basetypes.StringValue `tfsdk:"first_node_drained"`
	FirstNodeRebooted       basetypes.StringValue `tfsdk:"first_node_rebooted"`
	LastNodeRebootRecovered basetypes.StringValue `tfsdk:"last_node_reboot_recovered"`
	LastNodeUndrained       basetypes.StringValue `tfsdk:"last_node_undrained"`
	Result                  basetypes.StringValue `tfsdk:"result"`
	state                   attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["details"] = basetypes.ListType{
		ElemType: DetailsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["first_node_drained"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["first_node_rebooted"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_node_reboot_recovered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_node_undrained"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["result"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Details.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["details"] = val

		val, err = v.FirstNodeDrained.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["first_node_drained"] = val

		val, err = v.FirstNodeRebooted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["first_node_rebooted"] = val

		val, err = v.LastNodeRebootRecovered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_node_reboot_recovered"] = val

		val, err = v.LastNodeUndrained.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_node_undrained"] = val

		val, err = v.Result.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["result"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	details := types.ListValueMust(
		DetailsType{
			basetypes.ObjectType{
				AttrTypes: DetailsValue{}.AttributeTypes(ctx),
			},
		},
		v.Details.Elements(),
	)

	if v.Details.IsNull() {
		details = types.ListNull(
			DetailsType{
				basetypes.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Details.IsUnknown() {
		details = types.ListUnknown(
			DetailsType{
				basetypes.ObjectType{
					AttrTypes: DetailsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"details": basetypes.ListType{
			ElemType: DetailsValue{}.Type(ctx),
		},
		"first_node_drained":         basetypes.StringType{},
		"first_node_rebooted":        basetypes.StringType{},
		"last_node_reboot_recovered": basetypes.StringType{},
		"last_node_undrained":        basetypes.StringType{},
		"result":                     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"details":                    details,
			"first_node_drained":         v.FirstNodeDrained,
			"first_node_rebooted":        v.FirstNodeRebooted,
			"last_node_reboot_recovered": v.LastNodeRebootRecovered,
			"last_node_undrained":        v.LastNodeUndrained,
			"result":                     v.Result,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Details.Equal(other.Details) {
		return false
	}

	if !v.FirstNodeDrained.Equal(other.FirstNodeDrained) {
		return false
	}

	if !v.FirstNodeRebooted.Equal(other.FirstNodeRebooted) {
		return false
	}

	if !v.LastNodeRebootRecovered.Equal(other.LastNodeRebootRecovered) {
		return false
	}

	if !v.LastNodeUndrained.Equal(other.LastNodeUndrained) {
		return false
	}

	if !v.Result.Equal(other.Result) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"details": basetypes.ListType{
			ElemType: DetailsValue{}.Type(ctx),
		},
		"first_node_drained":         basetypes.StringType{},
		"first_node_rebooted":        basetypes.StringType{},
		"last_node_reboot_recovered": basetypes.StringType{},
		"last_node_undrained":        basetypes.StringType{},
		"result":                     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DetailsType{}

type DetailsType struct {
	basetypes.ObjectType
}

func (t DetailsType) Equal(o attr.Type) bool {
	other, ok := o.(DetailsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DetailsType) String() string {
	return "DetailsType"
}

func (t DetailsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	drainedTimeAttribute, ok := attributes["drained_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drained_time is missing from object`)

		return nil, diags
	}

	drainedTimeVal, ok := drainedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drained_time expected to be basetypes.StringValue, was: %T`, drainedTimeAttribute))
	}

	newNodeProfileAttribute, ok := attributes["new_node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`new_node_profile is missing from object`)

		return nil, diags
	}

	newNodeProfileVal, ok := newNodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`new_node_profile expected to be basetypes.StringValue, was: %T`, newNodeProfileAttribute))
	}

	newVersionAttribute, ok := attributes["new_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`new_version is missing from object`)

		return nil, diags
	}

	newVersionVal, ok := newVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`new_version expected to be basetypes.StringValue, was: %T`, newVersionAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	postCheckSuccessfulAttribute, ok := attributes["post_check_successful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`post_check_successful is missing from object`)

		return nil, diags
	}

	postCheckSuccessfulVal, ok := postCheckSuccessfulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`post_check_successful expected to be basetypes.BoolValue, was: %T`, postCheckSuccessfulAttribute))
	}

	preCheckSuccessfulAttribute, ok := attributes["pre_check_successful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_check_successful is missing from object`)

		return nil, diags
	}

	preCheckSuccessfulVal, ok := preCheckSuccessfulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_check_successful expected to be basetypes.BoolValue, was: %T`, preCheckSuccessfulAttribute))
	}

	previousNodeProfileAttribute, ok := attributes["previous_node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`previous_node_profile is missing from object`)

		return nil, diags
	}

	previousNodeProfileVal, ok := previousNodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`previous_node_profile expected to be basetypes.StringValue, was: %T`, previousNodeProfileAttribute))
	}

	previousVersionAttribute, ok := attributes["previous_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`previous_version is missing from object`)

		return nil, diags
	}

	previousVersionVal, ok := previousVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`previous_version expected to be basetypes.StringValue, was: %T`, previousVersionAttribute))
	}

	rebootRecoveryTimeAttribute, ok := attributes["reboot_recovery_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reboot_recovery_time is missing from object`)

		return nil, diags
	}

	rebootRecoveryTimeVal, ok := rebootRecoveryTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reboot_recovery_time expected to be basetypes.StringValue, was: %T`, rebootRecoveryTimeAttribute))
	}

	rebootTimeAttribute, ok := attributes["reboot_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reboot_time is missing from object`)

		return nil, diags
	}

	rebootTimeVal, ok := rebootTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reboot_time expected to be basetypes.StringValue, was: %T`, rebootTimeAttribute))
	}

	successAttribute, ok := attributes["success"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`success is missing from object`)

		return nil, diags
	}

	successVal, ok := successAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`success expected to be basetypes.BoolValue, was: %T`, successAttribute))
	}

	undrainedTimeAttribute, ok := attributes["undrained_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`undrained_time is missing from object`)

		return nil, diags
	}

	undrainedTimeVal, ok := undrainedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`undrained_time expected to be basetypes.StringValue, was: %T`, undrainedTimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DetailsValue{
		DrainedTime:         drainedTimeVal,
		NewNodeProfile:      newNodeProfileVal,
		NewVersion:          newVersionVal,
		Node:                nodeVal,
		PostCheckSuccessful: postCheckSuccessfulVal,
		PreCheckSuccessful:  preCheckSuccessfulVal,
		PreviousNodeProfile: previousNodeProfileVal,
		PreviousVersion:     previousVersionVal,
		RebootRecoveryTime:  rebootRecoveryTimeVal,
		RebootTime:          rebootTimeVal,
		Success:             successVal,
		UndrainedTime:       undrainedTimeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueNull() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateNull,
	}
}

func NewDetailsValueUnknown() DetailsValue {
	return DetailsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDetailsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DetailsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DetailsValue Attribute Value",
				"While creating a DetailsValue value, a missing attribute value was detected. "+
					"A DetailsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DetailsValue Attribute Type",
				"While creating a DetailsValue value, an invalid attribute value was detected. "+
					"A DetailsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DetailsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DetailsValue Attribute Value",
				"While creating a DetailsValue value, an extra attribute value was detected. "+
					"A DetailsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DetailsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	drainedTimeAttribute, ok := attributes["drained_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drained_time is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	drainedTimeVal, ok := drainedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drained_time expected to be basetypes.StringValue, was: %T`, drainedTimeAttribute))
	}

	newNodeProfileAttribute, ok := attributes["new_node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`new_node_profile is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	newNodeProfileVal, ok := newNodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`new_node_profile expected to be basetypes.StringValue, was: %T`, newNodeProfileAttribute))
	}

	newVersionAttribute, ok := attributes["new_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`new_version is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	newVersionVal, ok := newVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`new_version expected to be basetypes.StringValue, was: %T`, newVersionAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	postCheckSuccessfulAttribute, ok := attributes["post_check_successful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`post_check_successful is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	postCheckSuccessfulVal, ok := postCheckSuccessfulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`post_check_successful expected to be basetypes.BoolValue, was: %T`, postCheckSuccessfulAttribute))
	}

	preCheckSuccessfulAttribute, ok := attributes["pre_check_successful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pre_check_successful is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	preCheckSuccessfulVal, ok := preCheckSuccessfulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pre_check_successful expected to be basetypes.BoolValue, was: %T`, preCheckSuccessfulAttribute))
	}

	previousNodeProfileAttribute, ok := attributes["previous_node_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`previous_node_profile is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	previousNodeProfileVal, ok := previousNodeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`previous_node_profile expected to be basetypes.StringValue, was: %T`, previousNodeProfileAttribute))
	}

	previousVersionAttribute, ok := attributes["previous_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`previous_version is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	previousVersionVal, ok := previousVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`previous_version expected to be basetypes.StringValue, was: %T`, previousVersionAttribute))
	}

	rebootRecoveryTimeAttribute, ok := attributes["reboot_recovery_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reboot_recovery_time is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	rebootRecoveryTimeVal, ok := rebootRecoveryTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reboot_recovery_time expected to be basetypes.StringValue, was: %T`, rebootRecoveryTimeAttribute))
	}

	rebootTimeAttribute, ok := attributes["reboot_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reboot_time is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	rebootTimeVal, ok := rebootTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reboot_time expected to be basetypes.StringValue, was: %T`, rebootTimeAttribute))
	}

	successAttribute, ok := attributes["success"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`success is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	successVal, ok := successAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`success expected to be basetypes.BoolValue, was: %T`, successAttribute))
	}

	undrainedTimeAttribute, ok := attributes["undrained_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`undrained_time is missing from object`)

		return NewDetailsValueUnknown(), diags
	}

	undrainedTimeVal, ok := undrainedTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`undrained_time expected to be basetypes.StringValue, was: %T`, undrainedTimeAttribute))
	}

	if diags.HasError() {
		return NewDetailsValueUnknown(), diags
	}

	return DetailsValue{
		DrainedTime:         drainedTimeVal,
		NewNodeProfile:      newNodeProfileVal,
		NewVersion:          newVersionVal,
		Node:                nodeVal,
		PostCheckSuccessful: postCheckSuccessfulVal,
		PreCheckSuccessful:  preCheckSuccessfulVal,
		PreviousNodeProfile: previousNodeProfileVal,
		PreviousVersion:     previousVersionVal,
		RebootRecoveryTime:  rebootRecoveryTimeVal,
		RebootTime:          rebootTimeVal,
		Success:             successVal,
		UndrainedTime:       undrainedTimeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDetailsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DetailsValue {
	object, diags := NewDetailsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDetailsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DetailsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDetailsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDetailsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDetailsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDetailsValueMust(DetailsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DetailsType) ValueType(ctx context.Context) attr.Value {
	return DetailsValue{}
}

var _ basetypes.ObjectValuable = DetailsValue{}

type DetailsValue struct {
	DrainedTime         basetypes.StringValue `tfsdk:"drained_time"`
	NewNodeProfile      basetypes.StringValue `tfsdk:"new_node_profile"`
	NewVersion          basetypes.StringValue `tfsdk:"new_version"`
	Node                basetypes.StringValue `tfsdk:"node"`
	PostCheckSuccessful basetypes.BoolValue   `tfsdk:"post_check_successful"`
	PreCheckSuccessful  basetypes.BoolValue   `tfsdk:"pre_check_successful"`
	PreviousNodeProfile basetypes.StringValue `tfsdk:"previous_node_profile"`
	PreviousVersion     basetypes.StringValue `tfsdk:"previous_version"`
	RebootRecoveryTime  basetypes.StringValue `tfsdk:"reboot_recovery_time"`
	RebootTime          basetypes.StringValue `tfsdk:"reboot_time"`
	Success             basetypes.BoolValue   `tfsdk:"success"`
	UndrainedTime       basetypes.StringValue `tfsdk:"undrained_time"`
	state               attr.ValueState
}

func (v DetailsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["drained_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["new_node_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["new_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["post_check_successful"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["pre_check_successful"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["previous_node_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["previous_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reboot_recovery_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reboot_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["success"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["undrained_time"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.DrainedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drained_time"] = val

		val, err = v.NewNodeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["new_node_profile"] = val

		val, err = v.NewVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["new_version"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.PostCheckSuccessful.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["post_check_successful"] = val

		val, err = v.PreCheckSuccessful.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pre_check_successful"] = val

		val, err = v.PreviousNodeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["previous_node_profile"] = val

		val, err = v.PreviousVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["previous_version"] = val

		val, err = v.RebootRecoveryTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reboot_recovery_time"] = val

		val, err = v.RebootTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reboot_time"] = val

		val, err = v.Success.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["success"] = val

		val, err = v.UndrainedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["undrained_time"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DetailsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DetailsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DetailsValue) String() string {
	return "DetailsValue"
}

func (v DetailsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"drained_time":          basetypes.StringType{},
		"new_node_profile":      basetypes.StringType{},
		"new_version":           basetypes.StringType{},
		"node":                  basetypes.StringType{},
		"post_check_successful": basetypes.BoolType{},
		"pre_check_successful":  basetypes.BoolType{},
		"previous_node_profile": basetypes.StringType{},
		"previous_version":      basetypes.StringType{},
		"reboot_recovery_time":  basetypes.StringType{},
		"reboot_time":           basetypes.StringType{},
		"success":               basetypes.BoolType{},
		"undrained_time":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drained_time":          v.DrainedTime,
			"new_node_profile":      v.NewNodeProfile,
			"new_version":           v.NewVersion,
			"node":                  v.Node,
			"post_check_successful": v.PostCheckSuccessful,
			"pre_check_successful":  v.PreCheckSuccessful,
			"previous_node_profile": v.PreviousNodeProfile,
			"previous_version":      v.PreviousVersion,
			"reboot_recovery_time":  v.RebootRecoveryTime,
			"reboot_time":           v.RebootTime,
			"success":               v.Success,
			"undrained_time":        v.UndrainedTime,
		})

	return objVal, diags
}

func (v DetailsValue) Equal(o attr.Value) bool {
	other, ok := o.(DetailsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DrainedTime.Equal(other.DrainedTime) {
		return false
	}

	if !v.NewNodeProfile.Equal(other.NewNodeProfile) {
		return false
	}

	if !v.NewVersion.Equal(other.NewVersion) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.PostCheckSuccessful.Equal(other.PostCheckSuccessful) {
		return false
	}

	if !v.PreCheckSuccessful.Equal(other.PreCheckSuccessful) {
		return false
	}

	if !v.PreviousNodeProfile.Equal(other.PreviousNodeProfile) {
		return false
	}

	if !v.PreviousVersion.Equal(other.PreviousVersion) {
		return false
	}

	if !v.RebootRecoveryTime.Equal(other.RebootRecoveryTime) {
		return false
	}

	if !v.RebootTime.Equal(other.RebootTime) {
		return false
	}

	if !v.Success.Equal(other.Success) {
		return false
	}

	if !v.UndrainedTime.Equal(other.UndrainedTime) {
		return false
	}

	return true
}

func (v DetailsValue) Type(ctx context.Context) attr.Type {
	return DetailsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DetailsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drained_time":          basetypes.StringType{},
		"new_node_profile":      basetypes.StringType{},
		"new_version":           basetypes.StringType{},
		"node":                  basetypes.StringType{},
		"post_check_successful": basetypes.BoolType{},
		"pre_check_successful":  basetypes.BoolType{},
		"previous_node_profile": basetypes.StringType{},
		"previous_version":      basetypes.StringType{},
		"reboot_recovery_time":  basetypes.StringType{},
		"reboot_time":           basetypes.StringType{},
		"success":               basetypes.BoolType{},
		"undrained_time":        basetypes.StringType{},
	}
}
